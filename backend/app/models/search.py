"""
Search models for query and response tracking.

These models store search queries made by users and the
corresponding responses generated by the RAG system.
"""

import uuid

from sqlalchemy import Column, DateTime, ForeignKey, Integer, String, Text
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func

from ..db.base import Base


class SearchQuery(Base):
    """
    Search query model.

    Stores user search queries for history tracking and analytics.

    Attributes:
        id (UUID): Primary key
        user_id (UUID): Foreign key to users table
        query (str): The search query text
        session_id (str): Optional session identifier for grouping queries
        timestamp (datetime): When the query was made (indexed)

    Relationships:
        user: The user who made this query
        response: The response generated for this query (one-to-one)
        feedbacks: User feedback for this query (one-to-many)
    """

    __tablename__ = "search_queries"

    id = Column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        comment="Unique identifier for the search query",
    )
    user_id = Column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="User who made the query",
    )
    query = Column(
        Text,
        nullable=False,
        comment="The search query text",
    )
    session_id = Column(
        String(100),
        nullable=True,
        comment="Optional session ID for grouping queries",
    )
    timestamp = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
        index=True,
        comment="When the query was made",
    )

    # Relationships
    user = relationship("User", back_populates="search_queries")
    response = relationship(
        "SearchResponse",
        back_populates="query",
        uselist=False,
        cascade="all, delete-orphan",
        passive_deletes=True,
    )
    feedbacks = relationship(
        "UserFeedback",
        back_populates="query",
        cascade="all, delete-orphan",
        passive_deletes=True,
    )

    def __repr__(self) -> str:
        """String representation of the SearchQuery."""
        query_preview = self.query[:50] + "..." if len(self.query) > 50 else self.query
        return f"<SearchQuery(query='{query_preview}', user_id='{self.user_id}')>"


class SearchResponse(Base):
    """
    Search response model.

    Stores the RAG-generated responses for search queries.

    Attributes:
        id (UUID): Primary key
        query_id (UUID): Foreign key to search_queries table (unique)
        answer (str): The generated answer text
        sources (dict): JSON array of source documents used
        response_time_ms (int): Time taken to generate response in milliseconds
        timestamp (datetime): When the response was generated

    Relationships:
        query: The search query this response belongs to

    Sources JSON structure:
        [
            {
                "document_id": "uuid",
                "document_title": "str",
                "chunk_content": "str",
                "page_number": int,
                "relevance_score": float
            },
            ...
        ]
    """

    __tablename__ = "search_responses"

    id = Column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        comment="Unique identifier for the search response",
    )
    query_id = Column(
        UUID(as_uuid=True),
        ForeignKey("search_queries.id", ondelete="CASCADE"),
        nullable=False,
        unique=True,
        index=True,
        comment="The query this response belongs to (one-to-one)",
    )
    answer = Column(
        Text,
        nullable=False,
        comment="The generated answer text",
    )
    sources = Column(
        JSONB,
        nullable=False,
        comment="JSON array of source documents with metadata",
    )
    response_time_ms = Column(
        Integer,
        nullable=False,
        comment="Time taken to generate response in milliseconds",
    )
    timestamp = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
        comment="When the response was generated",
    )

    # Relationships
    query = relationship("SearchQuery", back_populates="response")

    def __repr__(self) -> str:
        """String representation of the SearchResponse."""
        return (
            f"<SearchResponse(query_id='{self.query_id}', "
            f"response_time={self.response_time_ms}ms)>"
        )
